<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: RV | PRT Blog]]></title>
  <link href="http://newfolder.github.io/blog/categories/rv/atom.xml" rel="self"/>
  <link href="http://newfolder.github.io/"/>
  <updated>2013-06-24T09:10:52-04:00</updated>
  <id>http://newfolder.github.io/</id>
  <author>
    <name><![CDATA[Kenneth Morton and Peter Torrione]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Random Variables (Part 1)]]></title>
    <link href="http://newfolder.github.io/blog/2013/01/31/random-variables-part-1/"/>
    <updated>2013-01-31T16:24:00-05:00</updated>
    <id>http://newfolder.github.io/blog/2013/01/31/random-variables-part-1</id>
    <content type="html"><![CDATA[<p>Hey ya'll! Probability theory and random variables come up all the time in machine learning. Classification techniques like Naive Bayes, the likelihood ratio test and maximum a posterior (MAP). A lot of times when someone says "Naive Bayes classification" they imply that they want to assume that the data is multinomial (counts from a fixed dictionary) or when they say "MAP classification" they mean they assumed Gaussian distributions for each of the classes. In reality though the choice of these distributions is flexible and assuming different distributions in the PRT is easy thanks to the RV objects. This is the first post in a series that will highlight how RV objects can be used for rapid classifier generation and showcase some of the ways that we use RVs for our research. In part 1, we are going to give an overview of some of the basic RV objects and show how they are used in some basic classification techniques.</p>




<h2>Contents</h2>


<div><ul><li><a href="#1">RV objects</a></li><li><a href="#7">Types of RV objects</a></li><li><a href="#9">Using RV Objects in Classifiers</a></li><li><a href="#12">Conclusions</a></li></ul></div>


<h2>RV objects<a name="1"></a></h2>


<p>Admittedly, the RV objects are one of the most under-documented features in the PRT. Sorry about that. I can take the blame there. Hopefully this post gets us started on fixing that.</p>


<p>Random variable objects are used to state that data is a random variable with an assumed distribution. Therefore, each prtRv*() assumes a different probability density function and implements the necessary methods to infer the parameters of the probability density function mle(), draw data with the same distribution draw(), and evaluate the likelihood of other data pdf() and logPdf().</p>




<p>
Let's make an RV object with a specified distribution. For the sake of this example we will use the multi-variate Normal distribution "MVN".
</p>




<pre class="codeinput">
rv = prtRvMvn(<span class="string">'mu'</span>,[1 2],<span class="string">'sigma'</span>,[1 0.5; 0.5 1])
</pre>


<pre class="codeoutput">rv = 
  prtRvMvn

  Properties:
                    name: 'Multi-Variate Normal'
        nameAbbreviation: 'RVMVN'
            isSupervised: 0
    isCrossValidateValid: 1
     covarianceStructure: 'full'
                      mu: [1 2]
                   sigma: [2x2 double]
             plotOptions: [1x1 prtOptions.prtOptionsRvPlot]
          verboseStorage: 1
         showProgressBar: 1
               isTrained: 0
          dataSetSummary: []
                 dataSet: []
                userData: [1x1 struct]
</pre>


<p>Let's draw some data from this RV object and put it into a prtDataSetClass().</p>


<pre class="codeinput">x = rv.draw(1000);
ds = prtDataSetClass(x);
</pre>


<p>Using this RV we can evaluate the log of the probability density function of the data that we drew.</p>


<pre class="codeinput">y = rv.logPdf(x);
</pre>


<p>RV objects also have some plot methods and plotLogPdf() is probably the most useful. Let's plot the log of the probability density function with the data that we drew fromt the pdf.</p>


<pre class="codeinput">rv.plotLogPdf()
hold <span class="string">on</span>
plot(ds);
hold <span class="string">off</span>
</pre>


<p><img vspace="5" hspace="5" src="/images/morton_blog_20130127_01.png" alt=""> <p>Although RV objects can be used by specifying the parameters of the densities their true power is flexibly modeling data. For example, let&rsquo;s make another RV MVN object without specifying parameters and use it to estimate the parameters of the data we drew. Here we will estimate the parameters using maximum likelihood estimation mle()</p><pre class="codeinput">rv2 = prtRvMvn;
rv2 = rv2.mle(ds); <span class="comment">% or rv2 = rv2.mle(x);</span>
estimatedMean = rv2.mu
estimateCovariance = rv2.sigma
</pre><pre class="codeoutput">estimatedMean =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.9647    1.9896
estimateCovariance =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.9479    0.4587
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.4587    0.9858
</pre><p>RV objects are actually sub-classes of prtActions() just like classifiers and regressors. This means that they have the train() and run() methods and can be cross-validated. By default, all RV objects implement train by calling the mle() method and implement run by using the logPdf() method. Therefore, some of the things we did above can be done as follows.</p><pre class="codeinput">rv2 = rv2.train(ds);
y = rv2.run(ds);
</pre><h2>Types of RV objects<a name="7"></a></h2><p>A list of available RVs that ship with the PRT can be displayed</p><pre class="codeinput">dirContents = what(fullfile(prtRoot,<span class="string">&lsquo;rv&rsquo;</span>));
availableRvs = dirContents.m
</pre><pre class="codeoutput">availableRvs =
&nbsp;&nbsp;&nbsp;&nbsp;&lsquo;prtRv.m&rsquo;
&nbsp;&nbsp;&nbsp;&nbsp;&lsquo;prtRvDiscrete.m&rsquo;
&nbsp;&nbsp;&nbsp;&nbsp;&lsquo;prtRvGmm.m&rsquo;
&nbsp;&nbsp;&nbsp;&nbsp;&lsquo;prtRvHmm.m&rsquo;
&nbsp;&nbsp;&nbsp;&nbsp;&lsquo;prtRvIndependent.m&rsquo;
&nbsp;&nbsp;&nbsp;&nbsp;&lsquo;prtRvKde.m&rsquo;
&nbsp;&nbsp;&nbsp;&nbsp;&lsquo;prtRvMemebershipModel.m&rsquo;
&nbsp;&nbsp;&nbsp;&nbsp;&lsquo;prtRvMixture.m&rsquo;
&nbsp;&nbsp;&nbsp;&nbsp;&lsquo;prtRvMultinomial.m&rsquo;
&nbsp;&nbsp;&nbsp;&nbsp;&lsquo;prtRvMvn.m&rsquo;
&nbsp;&nbsp;&nbsp;&nbsp;&lsquo;prtRvUniform.m&rsquo;
&nbsp;&nbsp;&nbsp;&nbsp;&lsquo;prtRvUniformImproper.m&rsquo;
&nbsp;&nbsp;&nbsp;&nbsp;&lsquo;prtRvVq.m&rsquo;
</pre><p>As you can, most of the standard probability densities have been implemented. In addition to standard things like prtRvMvn, prtRvDiscrete and prtRvMultinomial, there are also a few RVs that operate on other RVs like prtRvIndependent, prtRvMixture, prtRvGmm and prtRvHmm and there are a few RVs that can be used for more flexible density modeling like prtRvKde and prtRvVq. We will talk about some of these more advanced RVs in a later post.</p><h2>Using RV Objects in Classifiers<a name="9"></a></h2><p>There are two primary classifiers that make use of RV objects prtClassMap and prtClassGlrt. These classifiers have very similar performance but prtClassMap is able to handle M-ary classification problems so we will use that as our example.</p><pre class="codeinput">class = prtClassMap
</pre><pre class="codeoutput">class =
  prtClassMap</p>

<p>  Properties:</p>

<pre><code>                name: 'Maximum a Posteriori'
    nameAbbreviation: 'MAP'
        isNativeMary: 1
                 rvs: [1x1 prtRvMvn]
    twoClassParadigm: 'binary'
     internalDecider: []
        isSupervised: 1
isCrossValidateValid: 1
      verboseStorage: 1
     showProgressBar: 1
           isTrained: 0
      dataSetSummary: []
             dataSet: []
            userData: [1x1 struct]
</code></pre>

<p></pre><p>prtClassMap has a property rvs that lists the rvs used for each class in the incoming data set. If there is only one RV specified it is used to model all of the classes. Let&rsquo;s classify prtDataGenUnimodal using a quadratic classifier that arises by using a MAP classifier with MVN assumption for each class.</p><pre class="codeinput">class = prtClassMap(<span class="string">&lsquo;rvs&rsquo;</span>,prtRvMvn);
ds = prtDataGenUnimodal;</p>

<p>trainedClassifier = class.train(ds);
plot(trainedClassifier);
</pre><img vspace="5" hspace="5" src="/images/morton_blog_20130127_02.png" alt=""> <p>If our data is more complex, we can modify the assumptions of the distributions in both of our classes by setting the &ldquo;rvs&rdquo; parameter to something more flexible. Let&rsquo;s classify prtDataGenBimodal using prtRvKde which uses kernel density estimation.</p><pre class="codeinput">class = prtClassMap(<span class="string">&lsquo;rvs&rsquo;</span>,prtRvKde);
ds = prtDataGenBimodal;</p>

<p>trainedClassifier = class.train(ds);
plot(trainedClassifier);
</pre><img vspace="5" hspace="5" src="/images/morton_blog_20130127_03.png" alt=""> <h2>Conclusions<a name="12"></a></h2><p>As you can see, RVs are pretty powerful parts of the PRT and they can be used in other parts of the PRT to make things flexible.</p><p>In future posts we will talk about how RV objects are used to make flexible mixtures like the GMM and hidden Markov models and we will explore some things that are still in beta such as how we use prtBrv objects to perform variational Bayesian inference for models like Dirichlet process mixtures.</p></p>
]]></content>
  </entry>
  
</feed>
